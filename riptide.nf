/*
 * ============================================================================
 * Riptide FFA Pipeline - Fast Folding Algorithm Search
 * ============================================================================
 *
 * This file runs the riptide FFA search using the rffa command.
 * rffa handles everything: search, peak detection, clustering, harmonic
 * flagging, candidate filtering, and PNG plot generation.
 *
 * Input: Dedispersed time series (.inf files pointing to .dat files)
 *        Generated by PRESTO prepsubband or peasoup time series dump
 *
 * Output: CSV tables (peaks, clusters, candidates), JSON candidates, PNG plots
 *
 * Usage:
 *
 *   # Add FFA search to existing pipelines:
 *   nextflow run elden.nf -entry full --riptide.run_ffa_search true
 *   nextflow run elden.nf -entry presto_pipeline --riptide.run_ffa_search true
 *
 *   # Standalone riptide on pre-existing time series:
 *   nextflow run elden.nf -entry run_riptide_on_timeseries \
 *       --timeseries_input_dir /path/to/TIMESERIES
 *
 *   # Standalone riptide with PRESTO dedispersion:
 *   nextflow run elden.nf -entry run_riptide \
 *       --input_fil /path/to/file.fil --riptide.backend presto
 *
 * Configuration:
 *   Edit riptide_config.yml in your basedir (copied during setup_basedir)
 *
 * Documentation:
 *   https://riptide-ffa.readthedocs.io/en/latest/pipeline.html
 *
 * ============================================================================
 */

// Import PRESTO processes for standalone riptide with PRESTO dedispersion
include { presto_rfifind } from './presto'
include { presto_prepdata_zerodm } from './presto'
include { presto_accelsearch_zerodm } from './presto'
include { presto_prepsubband } from './presto'


/*
 * Riptide FFA Search
 * Runs rffa command on dedispersed time series files (.inf files)
 * rffa automatically reads .dat files referenced by the .inf files
 *
 * rffa performs:
 *   - FFA search across all DM trials
 *   - Peak detection in periodograms
 *   - Clustering of peaks across DM
 *   - Harmonic flagging and removal
 *   - Candidate filtering (DM, SNR thresholds)
 *   - PNG plot generation (if enabled in config)
 *
 * Outputs:
 *   - peaks.csv: All detected periodogram peaks
 *   - clusters.csv: Peaks grouped by frequency proximity
 *   - candidates.csv: Final candidates (harmonics removed if configured)
 *   - *.json: One JSON file per candidate (loadable with riptide.load_json)
 *   - *.png: One plot per candidate (if plot_candidates: true in config)
 */
process riptide_ffa_search {
    label 'riptide'
    label 'long'

    publishDir "${params.basedir}/${params.runID}/RIPTIDE_SEARCH", mode: 'copy'

    input:
    path inf_files
    path config_file

    output:
    path "candidates.csv", emit: candidates_csv, optional: true
    path "peaks.csv", emit: peaks_csv, optional: true
    path "clusters.csv", emit: clusters_csv, optional: true
    path "*.json", emit: candidate_json, optional: true
    path "*.png", emit: candidate_plots, optional: true

    script:
    """
    # Run riptide FFA search pipeline
    # rffa reads .inf files and automatically loads corresponding .dat files
    rffa -c ${config_file} -o . ${inf_files}
    """
}


/* ============================================================================
 * WORKFLOWS
 * ============================================================================ */


/*
 * Run Riptide FFA search on .inf files
 * Simple wrapper that runs rffa with the config file
 */
workflow riptide_search {
    take:
    inf_files_ch       // Channel of .inf files (can be collected or flat)
    config_file_ch     // Channel of riptide YAML config file

    main:
    riptide_ffa_search(inf_files_ch.collect(), config_file_ch)

    emit:
    candidates_csv = riptide_ffa_search.out.candidates_csv
    peaks_csv = riptide_ffa_search.out.peaks_csv
    clusters_csv = riptide_ffa_search.out.clusters_csv
    candidate_json = riptide_ffa_search.out.candidate_json
    candidate_plots = riptide_ffa_search.out.candidate_plots
}


/*
 * Standalone Riptide Pipeline
 * Generates time series using selected backend, then runs FFA search
 */
workflow run_riptide {
    main:
    // Validate inputs
    if (!params.input_fil && !params.timeseries_input_dir) {
        error """
        ERROR: Either --input_fil or --timeseries_input_dir required

        Usage:
          # With PRESTO dedispersion:
          nextflow run elden.nf -entry run_riptide --input_fil /path/to/file.fil --riptide.backend presto

          # With pre-existing time series:
          nextflow run elden.nf -entry run_riptide --timeseries_input_dir /path/to/TIMESERIES
        """
    }

    // Get riptide config file
    def config_path = params.riptide?.config_file ?: "${params.basedir}/riptide_config.yml"
    if (!file(config_path).exists()) {
        error "ERROR: Riptide config file not found: ${config_path}. Run setup_basedir first or specify --riptide.config_file"
    }
    config_file_ch = Channel.fromPath(config_path)

    // Determine input source
    def backend = params.riptide?.backend ?: 'presto'

    if (params.timeseries_input_dir) {
        // Use pre-existing time series
        log.info "Running Riptide FFA on pre-existing time series from: ${params.timeseries_input_dir}"
        inf_files_ch = Channel.fromPath("${params.timeseries_input_dir}/*.inf")

    } else if (backend == 'presto') {
        // Use PRESTO for dedispersion
        log.info "Running Riptide FFA with PRESTO dedispersion on: ${params.input_fil}"

        input_file_ch = Channel.fromPath(params.input_fil)

        // RFI detection
        presto_rfifind(input_file_ch)

        // Zero-DM prepdata for birdie detection
        presto_prepdata_zerodm(
            input_file_ch,
            presto_rfifind.out.rfi_mask,
            presto_rfifind.out.rfi_stats,
            presto_rfifind.out.rfi_inf
        )

        // Birdie detection
        presto_accelsearch_zerodm(
            presto_prepdata_zerodm.out.dat_file,
            presto_prepdata_zerodm.out.inf_file
        )

        // Get DM ranges
        def dm_ranges = params.presto?.dm_ranges ?: [
            [dm_low: 0.0, dm_high: 100.0, dm_step: 0.5, downsamp: 1]
        ]
        dm_ranges_ch = Channel.from(dm_ranges).map { range ->
            tuple(range.dm_low, range.dm_high, range.dm_step, range.downsamp)
        }

        // Dedisperse
        presto_prepsubband(
            input_file_ch,
            presto_prepdata_zerodm.out.inf_file,
            presto_rfifind.out.rfi_mask,
            presto_rfifind.out.rfi_stats,
            dm_ranges_ch
        )

        inf_files_ch = presto_prepsubband.out.inf_files.flatten()

    } else if (backend == 'peasoup') {
        // Use peasoup time series dump
        if (!params.timeseries_input_dir) {
            error """
            ERROR: --timeseries_input_dir required for peasoup backend

            First run peasoup with dump_timeseries=true, then:
              nextflow run elden.nf -entry run_riptide \\
                  --timeseries_input_dir /path/to/TIMESERIES \\
                  --riptide.backend peasoup
            """
        }
        inf_files_ch = Channel.fromPath("${params.timeseries_input_dir}/*.inf")

    } else {
        error "ERROR: Unknown backend '${backend}'. Use 'presto' or 'peasoup'."
    }

    // Run riptide FFA search
    riptide_search(inf_files_ch, config_file_ch)

    emit:
    candidates_csv = riptide_search.out.candidates_csv
    candidate_plots = riptide_search.out.candidate_plots
}


/*
 * Run Riptide on pre-existing time series (.dat/.inf files)
 * Simplified entry point for when time series already exist
 */
workflow run_riptide_on_timeseries {
    main:
    if (!params.timeseries_input_dir) {
        error """
        ERROR: --timeseries_input_dir required (directory with .dat/.inf files)

        Usage:
          nextflow run elden.nf -entry run_riptide_on_timeseries \\
              --timeseries_input_dir /path/to/TIMESERIES
        """
    }

    // Get config file
    def config_path = params.riptide?.config_file ?: "${params.basedir}/riptide_config.yml"
    if (!file(config_path).exists()) {
        error "ERROR: Riptide config file not found: ${config_path}. Run setup_basedir first or specify --riptide.config_file"
    }
    config_file_ch = Channel.fromPath(config_path)

    // Get .inf files
    inf_files_ch = Channel.fromPath("${params.timeseries_input_dir}/*.inf")

    // Run riptide FFA search
    riptide_search(inf_files_ch, config_file_ch)

    emit:
    candidates_csv = riptide_search.out.candidates_csv
    candidate_plots = riptide_search.out.candidate_plots
}
